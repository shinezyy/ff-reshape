From 40509c923c7354f3a1bdd916a0bbeb5c571f85e9 Mon Sep 17 00:00:00 2001
From: Zhou Yaoyang <shinezyy@qq.com>
Date: Mon, 22 Jun 2020 12:38:44 +0800
Subject: [PATCH 01/13] add a simple Loop buffer

Change-Id: Idebd3d71cb94378229d461e095ae5f2b0b26fa24
---
 src/cpu/o3/LoopBuffer.py  |  10 +++
 src/cpu/o3/O3CPU.py       |   2 +
 src/cpu/o3/SConscript     |   3 +
 src/cpu/o3/fetch.hh       |  12 +++-
 src/cpu/o3/fetch_impl.hh  |  78 +++++++++++++++++++----
 src/cpu/o3/loop_buffer.cc | 127 ++++++++++++++++++++++++++++++++++++++
 src/cpu/o3/loop_buffer.hh |  83 +++++++++++++++++++++++++
 7 files changed, 302 insertions(+), 13 deletions(-)
 create mode 100644 src/cpu/o3/LoopBuffer.py
 create mode 100644 src/cpu/o3/loop_buffer.cc
 create mode 100644 src/cpu/o3/loop_buffer.hh

diff --git a/src/cpu/o3/LoopBuffer.py b/src/cpu/o3/LoopBuffer.py
new file mode 100644
index 000000000..5daf79d98
--- /dev/null
+++ b/src/cpu/o3/LoopBuffer.py
@@ -0,0 +1,10 @@
+from m5.SimObject import SimObject
+from m5.params import *
+
+class LoopBuffer(SimObject):
+    type = 'LoopBuffer'
+    cxx_class = 'LoopBuffer'
+    cxx_header = 'cpu/o3/loop_buffer.hh'
+
+    numEntries = Param.Unsigned(32, "Number of entries")
+    entrySize = Param.Unsigned(64, "Size of entries in bytes")
diff --git a/src/cpu/o3/O3CPU.py b/src/cpu/o3/O3CPU.py
index 04c405deb..9d3192cf3 100644
--- a/src/cpu/o3/O3CPU.py
+++ b/src/cpu/o3/O3CPU.py
@@ -48,6 +48,7 @@ from FUPool import *
 from O3Checker import O3Checker
 from BranchPredictor import *
 from BranchTrace import *
+from LoopBuffer import *
 
 class DerivO3CPU(BaseCPU):
     type = 'DerivO3CPU'
@@ -178,6 +179,7 @@ class DerivO3CPU(BaseCPU):
     #branchPred = Param.BranchPredictor(LocalBP(numThreads =
     #                                                   Parent.numThreads),
                                        "Branch Predictor")
+    loopBuffer = Param.LoopBuffer(LoopBuffer(), "Loopo Buffer")
     needsTSO = Param.Bool(buildEnv['TARGET_ISA'] == 'x86',
                           "Enable TSO Memory model")
 
diff --git a/src/cpu/o3/SConscript b/src/cpu/o3/SConscript
index 8d157d57a..b029051c4 100755
--- a/src/cpu/o3/SConscript
+++ b/src/cpu/o3/SConscript
@@ -35,6 +35,7 @@ Import('*')
 if 'O3CPU' in env['CPU_MODELS']:
     SimObject('FUPool.py')
     SimObject('FuncUnitConfig.py')
+    SimObject('LoopBuffer.py')
     SimObject('O3CPU.py')
 
     Source('base_dyn_inst.cc')
@@ -48,6 +49,7 @@ if 'O3CPU' in env['CPU_MODELS']:
     Source('fu_pool.cc')
     Source('iew.cc')
     Source('inst_queue.cc')
+    Source('loop_buffer.cc')
     Source('lsq.cc')
     Source('lsq_unit.cc')
     Source('mem_dep_unit.cc')
@@ -73,6 +75,7 @@ if 'O3CPU' in env['CPU_MODELS']:
     DebugFlag('Writeback')
     DebugFlag('DLarge')
     DebugFlag('BranchResolve')
+    DebugFlag('LoopBuffer')
 
     CompoundFlag('O3CPUAll', [ 'Fetch', 'Decode', 'Rename', 'IEW', 'Commit',
         'IQ', 'ROB', 'FreeList', 'LSQ', 'LSQUnit', 'StoreSet', 'MemDepUnit',
diff --git a/src/cpu/o3/fetch.hh b/src/cpu/o3/fetch.hh
index da7ba4bb3..fead258a5 100644
--- a/src/cpu/o3/fetch.hh
+++ b/src/cpu/o3/fetch.hh
@@ -48,6 +48,7 @@
 #include "arch/utility.hh"
 #include "base/statistics.hh"
 #include "config/the_isa.hh"
+#include "cpu/o3/loop_buffer.hh"
 #include "cpu/pc_event.hh"
 #include "cpu/pred/bpred_unit.hh"
 #include "cpu/timebuf.hh"
@@ -350,9 +351,9 @@ class DefaultFetch
     void fetch(bool &status_change);
 
     /** Align a PC to the start of a fetch buffer block. */
-    Addr fetchBufferAlignPC(Addr addr)
+    Addr bufferAlignPC(Addr addr, Addr mask)
     {
-        return (addr & ~(fetchBufferMask));
+        return (addr & ~mask);
     }
 
     /** The decoder. */
@@ -573,6 +574,13 @@ class DefaultFetch
     Stats::Formula branchRate;
     /** Number of instruction fetched per cycle. */
     Stats::Formula fetchRate;
+
+    Stats::Scalar fetchFromLoopBuffer;
+  private:
+
+    LoopBuffer *lbuf;
+
+    uint8_t *foundLine;
 };
 
 #endif //__CPU_O3_FETCH_HH__
diff --git a/src/cpu/o3/fetch_impl.hh b/src/cpu/o3/fetch_impl.hh
index 5cb7cb198..5813bb437 100644
--- a/src/cpu/o3/fetch_impl.hh
+++ b/src/cpu/o3/fetch_impl.hh
@@ -94,7 +94,8 @@ DefaultFetch<Impl>::DefaultFetch(O3CPU *_cpu, DerivO3CPUParams *params)
       fetchQueueSize(params->fetchQueueSize),
       numThreads(params->numThreads),
       numFetchingThreads(params->smtNumFetchingThreads),
-      finishTranslationEvent(this)
+      finishTranslationEvent(this),
+      foundLine(nullptr)
 {
     if (numThreads > Impl::MaxThreads)
         fatal("numThreads (%d) is larger than compiled limit (%d),\n"
@@ -150,6 +151,7 @@ DefaultFetch<Impl>::DefaultFetch(O3CPU *_cpu, DerivO3CPUParams *params)
     }
 
     branchPred = params->branchPred;
+    lbuf = params->loopBuffer;
 
     for (ThreadID tid = 0; tid < numThreads; tid++) {
         decoder[tid] = new TheISA::Decoder(params->isa[tid]);
@@ -297,6 +299,10 @@ DefaultFetch<Impl>::regStats()
         .desc("Number of inst fetches per cycle")
         .flags(Stats::total);
     fetchRate = fetchedInsts / cpu->numCycles;
+
+    fetchFromLoopBuffer
+        .name(name() + ".fetchFromLoopBuffer")
+        .desc("Times that fetch from loop buffer");
 }
 
 template<class Impl>
@@ -395,6 +401,14 @@ DefaultFetch<Impl>::processCacheCompletion(PacketPtr pkt)
     memcpy(fetchBuffer[tid], pkt->getConstPtr<uint8_t>(), fetchBufferSize);
     fetchBufferValid[tid] = true;
 
+    if (lbuf->hasPendingRecordTxn() &&
+            (lbuf->align(lbuf->getPendingEntryTarget())) == fetchBufferPC[tid]) {
+        memcpy(lbuf->getPendingEntryPtr(), pkt->getConstPtr<uint8_t>(),
+                lbuf->entrySize);
+        lbuf->setFetched(lbuf->getPendingEntryTarget());
+        lbuf->clearPending();
+    }
+
     // Wake up the CPU (if it went to sleep and was waiting on
     // this completion event).
     cpu->wakeCPU();
@@ -611,7 +625,7 @@ DefaultFetch<Impl>::fetchCacheLine(Addr vaddr, ThreadID tid, Addr pc)
     }
 
     // Align the fetch address to the start of a fetch buffer segment.
-    Addr fetchBufferBlockPC = fetchBufferAlignPC(vaddr);
+    Addr fetchBufferBlockPC = bufferAlignPC(vaddr, fetchBufferMask);
 
     DPRINTF(Fetch, "[tid:%i] Fetching cache line %#x for addr %#x\n",
             tid, fetchBufferBlockPC, vaddr);
@@ -1174,6 +1188,12 @@ DefaultFetch<Impl>::fetch(bool &status_change)
 
     bool inRom = isRomMicroPC(thisPC.microPC());
 
+    foundLine = lbuf->getBufferedLine(fetchAddr);
+
+    bool used_loopbuffer = foundLine != nullptr;
+
+    Addr lbuf_start_pc = foundLine ? lbuf->align(fetchAddr) : 0;
+
     // If returning from the delay of a cache miss, then update the status
     // to running, otherwise do the cache access.  Possibly move this up
     // to tick() function.
@@ -1184,13 +1204,13 @@ DefaultFetch<Impl>::fetch(bool &status_change)
         status_change = true;
     } else if (fetchStatus[tid] == Running) {
         // Align the fetch PC so its at the start of a fetch buffer segment.
-        Addr fetchBufferBlockPC = fetchBufferAlignPC(fetchAddr);
+        Addr fetchBufferBlockPC = bufferAlignPC(fetchAddr, fetchBufferMask);
 
         // If buffer is no longer valid or fetchAddr has moved to point
         // to the next cache block, AND we have no remaining ucode
         // from a macro-op, then start fetch from icache.
         if (!(fetchBufferValid[tid] && fetchBufferBlockPC == fetchBufferPC[tid])
-            && !inRom && !macroop[tid]) {
+            && !inRom && !macroop[tid] && !foundLine) {
             DPRINTF(Fetch, "[tid:%i]: Attempting to translate and read "
                     "instruction, starting at PC %s.\n", tid, thisPC);
 
@@ -1246,27 +1266,40 @@ DefaultFetch<Impl>::fetch(bool &status_change)
         reinterpret_cast<TheISA::MachInst *>(fetchBuffer[tid]);
 
     const unsigned numInsts = fetchBufferSize / instSize;
-    unsigned blkOffset = (fetchAddr - fetchBufferPC[tid]) / instSize;
+    unsigned blkOffset =
+        (fetchAddr - fetchBufferPC[tid]) / instSize;
 
     // Loop through instruction memory from the cache.
     // Keep issuing while fetchWidth is available and branch is not
     // predicted taken
     while (numInst < fetchWidth && fetchQueue[tid].size() < fetchQueueSize
-           && !predictedBranch && !quiesce) {
+           && !(predictedBranch && !foundLine) && !quiesce) {
         // We need to process more memory if we aren't going to get a
         // StaticInst from the rom, the current macroop, or what's already
         // in the decoder.
         bool needMem = !inRom && !curMacroop &&
             !decoder[tid]->instReady();
         fetchAddr = (thisPC.instAddr() + pcOffset) & BaseCPU::PCMask;
-        Addr fetchBufferBlockPC = fetchBufferAlignPC(fetchAddr);
+
+        Addr fetchBufferBlockPC = bufferAlignPC(fetchAddr, fetchBufferMask);
 
         if (needMem) {
             // If buffer is no longer valid or fetchAddr has moved to point
             // to the next cache block then start fetch from icache.
-            if (!fetchBufferValid[tid] ||
-                fetchBufferBlockPC != fetchBufferPC[tid])
+            if (foundLine) {
+                fetchFromLoopBuffer++;
+                blkOffset = (fetchAddr - lbuf_start_pc) / instSize;
+                unsigned lbuf_entry_insts = lbuf->entrySize / instSize;
+                cacheInsts = reinterpret_cast<TheISA::MachInst *>(foundLine);
+
+                if (blkOffset > lbuf_entry_insts) {
+                    break;
+                }
+
+            } else if (!fetchBufferValid[tid] ||
+                fetchBufferBlockPC != fetchBufferPC[tid]) {
                 break;
+            }
 
             if (blkOffset >= numInsts) {
                 // We need to process more memory, but we've run out of the
@@ -1339,10 +1372,32 @@ DefaultFetch<Impl>::fetch(bool &status_change)
             predictedBranch |= thisPC.branching();
             predictedBranch |=
                 lookupAndUpdateNextPC(instruction, nextPC);
+
             if (predictedBranch) {
+                // predicted backward branch
                 DPRINTF(Fetch, "Branch detected with PC = %s\n", thisPC);
             }
 
+            Addr npc = nextPC.instAddr();
+            if (predictedBranch && thisPC.instAddr() > npc) {
+                DPRINTF(Fetch, "Backward branch detected with PC = %s\n", thisPC);
+
+                foundLine = lbuf->getBufferedLine(npc);
+
+                if (!foundLine) {
+                    // mark a Txn
+                    lbuf->processNewControl(npc);
+                } else {
+                    lbuf->updateControl(npc);
+
+                    if (used_loopbuffer) {
+                        foundLine = nullptr; // port limitation -> cannot read anymore
+                    } else {
+                        used_loopbuffer = true;
+                    }
+                }
+            }
+
             newMacro |= thisPC.instAddr() != nextPC.instAddr();
 
             // Move to the next instruction, unless we have a branch.
@@ -1376,6 +1431,7 @@ DefaultFetch<Impl>::fetch(bool &status_change)
     if (predictedBranch) {
         DPRINTF(Fetch, "[tid:%i]: Done fetching, predicted branch "
                 "instruction encountered.\n", tid);
+
     } else if (numInst >= fetchWidth) {
         DPRINTF(Fetch, "[tid:%i]: Done fetching, reached fetch bandwidth "
                 "for this cycle.\n", tid);
@@ -1396,7 +1452,7 @@ DefaultFetch<Impl>::fetch(bool &status_change)
     // pipeline a fetch if we're crossing a fetch buffer boundary and not in
     // a state that would preclude fetching
     fetchAddr = (thisPC.instAddr() + pcOffset) & BaseCPU::PCMask;
-    Addr fetchBufferBlockPC = fetchBufferAlignPC(fetchAddr);
+    Addr fetchBufferBlockPC = bufferAlignPC(fetchAddr, fetchBufferMask);
     issuePipelinedIfetch[tid] = fetchBufferBlockPC != fetchBufferPC[tid] &&
         fetchStatus[tid] != IcacheWaitResponse &&
         fetchStatus[tid] != ItlbWait &&
@@ -1616,7 +1672,7 @@ DefaultFetch<Impl>::pipelineIcacheAccesses(ThreadID tid)
     Addr fetchAddr = (thisPC.instAddr() + pcOffset) & BaseCPU::PCMask;
 
     // Align the fetch PC so its at the start of a fetch buffer segment.
-    Addr fetchBufferBlockPC = fetchBufferAlignPC(fetchAddr);
+    Addr fetchBufferBlockPC = bufferAlignPC(fetchAddr, fetchBufferMask);
 
     // Unless buffer already got the block, fetch it from icache.
     if (!(fetchBufferValid[tid] && fetchBufferBlockPC == fetchBufferPC[tid])) {
diff --git a/src/cpu/o3/loop_buffer.cc b/src/cpu/o3/loop_buffer.cc
new file mode 100644
index 000000000..fa196452b
--- /dev/null
+++ b/src/cpu/o3/loop_buffer.cc
@@ -0,0 +1,127 @@
+#include "cpu/o3/loop_buffer.hh"
+
+LoopBuffer::LoopBuffer(LoopBufferParams *params)
+    :
+        SimObject(params),
+        numEntries(params->numEntries),
+        _name("LoopBuffer"),
+        entrySize(params->entrySize),
+        mask(~(entrySize - 1))
+{
+    assert(numEntries >= 2 * evictRange);
+}
+
+LoopBuffer::~LoopBuffer()
+{
+}
+
+void
+LoopBuffer::processNewControl(Addr target)
+{
+    if (table.count(target)) {
+        assert(table[target].valid && !table[target].fetched);
+        return;
+    }
+    table[target];
+    table[target].instPayload = new uint8_t[entrySize];
+    table[target].valid = true;
+    table[target].fetched = false;
+    table[target].used = 0;
+
+    rank.emplace_back(table.find(target));
+
+    if (table.size() > numEntries) {
+        auto evicted = random_mt.random<unsigned>(1, 1 + evictRange);
+        OrderRIt it = rank.rbegin(); // pointed to newly inserted
+        std::advance(it, evicted);
+
+        delete (*it)->second.instPayload;
+
+        table.erase((*it));
+
+        rank.erase(std::next(it).base());
+    }
+
+    pending = true;
+    pendingTarget = target;
+
+    assert(rank.size() == table.size());
+}
+
+void
+LoopBuffer::updateControl(Addr target)
+{
+    assert(table.count(target));
+    auto used = ++table[target].used;
+
+    OrderIt insert_pos = rank.begin(), e = rank.end();
+    for (; insert_pos != e; insert_pos++) {
+        if ((*insert_pos)->second.used < used) {
+            break;
+        }
+    }
+
+    if (insert_pos != e) {
+        OrderIt ele_pos = rank.begin();
+        for (; ele_pos != e; ele_pos++) {
+            if ((*ele_pos)->first == target) {
+                break;
+            }
+        }
+
+        assert(ele_pos != e);
+
+        rank.splice(insert_pos, rank, ele_pos, std::next(ele_pos));
+    }
+
+    assert(rank.size() == table.size());
+}
+
+bool
+LoopBuffer::hasPendingRecordTxn()
+{
+    return pending;
+}
+
+uint8_t*
+LoopBuffer::getPendingEntryPtr()
+{
+    assert(table.count(pendingTarget));
+    return table[pendingTarget].instPayload;
+}
+
+Addr
+LoopBuffer::getPendingEntryTarget()
+{
+    return pendingTarget;
+}
+
+void
+LoopBuffer::clearPending()
+{
+    pending = false;
+}
+
+uint8_t*
+LoopBuffer::getBufferedLine(Addr pc)
+{
+    if (table.count(pc) && table[pc].valid && table[pc].fetched) {
+        return table[pc].instPayload;
+    } else {
+        return nullptr;
+    }
+}
+
+void
+LoopBuffer::setFetched(Addr target)
+{
+    assert(table.count(target));
+    assert(table[target].valid && !table[target].fetched);
+    table[target].fetched = true;
+}
+
+LoopBuffer *
+LoopBufferParams::create()
+{
+    return new LoopBuffer(this);
+}
diff --git a/src/cpu/o3/loop_buffer.hh b/src/cpu/o3/loop_buffer.hh
new file mode 100644
index 000000000..5593bae83
--- /dev/null
+++ b/src/cpu/o3/loop_buffer.hh
@@ -0,0 +1,83 @@
+#ifndef __CPU_O3_LOOPBUFFER_HH__
+#define __CPU_O3_LOOPBUFFER_HH__
+
+
+#include <cinttypes>
+#include <list>
+#include <map>
+
+#include "base/random.hh"
+#include "base/types.hh"
+#include "params/LoopBuffer.hh"
+#include "sim/sim_object.hh"
+
+struct LoopRecordTransaction {
+    bool pending{};
+    Addr backwardBranchPC;
+};
+
+struct LoopEntry {
+    uint8_t *instPayload;
+    bool valid{};
+    bool fetched{};
+    uint32_t used{};
+
+};
+
+class LoopBuffer : public SimObject
+{
+    unsigned numEntries;
+
+    using LoopTable = std::map<Addr, LoopEntry>;
+
+    using LTit = LoopTable::iterator;
+
+    using OrderedList = std::list<LTit>;
+
+    using OrderIt = OrderedList::iterator;
+
+    using OrderRIt = OrderedList::reverse_iterator;
+
+    LoopTable table;
+
+    OrderedList rank;
+
+    bool pending{};
+
+    Addr pendingTarget{};
+  public:
+
+    LoopBuffer(LoopBufferParams *params);
+
+    ~LoopBuffer();
+
+    const std::string _name;
+
+    const std::string name() const {return _name;}
+
+    const unsigned entrySize;
+
+    const Addr mask;
+
+    const unsigned evictRange{10};
+
+    void processNewControl(Addr target);
+
+    void updateControl(Addr target);
+
+    bool hasPendingRecordTxn();
+
+    uint8_t* getPendingEntryPtr();
+
+    void setFetched(Addr target);
+
+    Addr getPendingEntryTarget();
+
+    void clearPending();
+
+    uint8_t* getBufferedLine(Addr branch_pc);
+
+    Addr align(Addr addr) {return addr & mask;}
+};
+
+#endif //__CPU_O3_LOOPBUFFER_HH__
-- 
2.29.2

